{"files":[{"path":["/","Users","anthonypelusocook","moodring-vibe","moodring_backend","src","lib.rs"],"content":"use base64::Engine;\nuse chrono::NaiveDateTime;\nuse diesel::prelude::*;\nuse rocket::serde::{Deserialize, Serialize};\nuse std::env;\n\npub mod schema;\n\npub type DbPool = diesel::r2d2::Pool<diesel::r2d2::ConnectionManager<PgConnection>>;\n\n#[derive(Queryable, Serialize, Deserialize, Clone, PartialEq, Debug)]\n#[serde(crate = \"rocket::serde\")]\n#[diesel(table_name = schema::users)]\npub struct User {\n    pub id: i32,\n    pub spotify_id: String,\n    pub email: String,\n    pub display_name: Option<String>,\n    pub spotify_access_token: Option<String>,\n    pub spotify_refresh_token: Option<String>,\n    pub token_expires_at: Option<NaiveDateTime>,\n    pub profile_image_url: Option<String>,\n    pub created_at: NaiveDateTime,\n    pub updated_at: NaiveDateTime,\n}\n\n#[derive(Insertable, Deserialize, Clone, Debug)]\n#[serde(crate = \"rocket::serde\")]\n#[diesel(table_name = schema::users)]\npub struct NewUser {\n    pub spotify_id: String,\n    pub email: String,\n    pub display_name: Option<String>,\n    pub spotify_access_token: Option<String>,\n    pub spotify_refresh_token: Option<String>,\n    pub token_expires_at: Option<NaiveDateTime>,\n    pub profile_image_url: Option<String>,\n}\n\n#[derive(Deserialize, Clone, Debug)]\n#[serde(crate = \"rocket::serde\")]\npub struct AuthRequest {\n    pub code: String,\n    pub code_verifier: String,\n}\n\n#[derive(Serialize, Clone, Debug)]\n#[serde(crate = \"rocket::serde\")]\npub struct AuthResponse {\n    pub user: User,\n    pub access_token: String,\n}\n\n#[derive(Deserialize, Serialize, Debug)]\n#[serde(crate = \"rocket::serde\")]\npub struct SpotifyTokenResponse {\n    pub access_token: String,\n    pub token_type: String,\n    pub scope: String,\n    pub expires_in: i64,\n    pub refresh_token: Option<String>,\n}\n\n#[derive(Deserialize, Serialize, Debug)]\n#[serde(crate = \"rocket::serde\")]\npub struct SpotifyUserProfile {\n    pub id: String,\n    pub email: Option<String>,\n    pub display_name: Option<String>,\n    pub images: Vec<SpotifyImage>,\n}\n\n#[derive(Deserialize, Serialize, Debug)]\n#[serde(crate = \"rocket::serde\")]\npub struct SpotifyImage {\n    pub url: String,\n    pub height: Option<u32>,\n    pub width: Option<u32>,\n}\n\npub async fn authenticate_user_with_spotify(\n    pool: &DbPool,\n    auth_request: AuthRequest,\n) -> Result<AuthResponse, String> {\n    use schema::users::dsl::*;\n\n    let pool = pool.clone();\n\n    tokio::task::spawn_blocking(move || {\n        let mut conn = pool\n            .get()\n            .map_err(|e| format!(\"Failed to get connection: {e}\"))?;\n\n        // Step 1: Exchange authorization code for access token\n        let client_id = env::var(\"SPOTIFY_CLIENT_ID\").map_err(|_| \"SPOTIFY_CLIENT_ID not set\")?;\n        let client_secret =\n            env::var(\"SPOTIFY_CLIENT_SECRET\").map_err(|_| \"SPOTIFY_CLIENT_SECRET not set\")?;\n\n        let token_response = tokio::task::block_in_place(|| {\n            let rt = tokio::runtime::Handle::current();\n            rt.block_on(async {\n                let client = reqwest::Client::new();\n                let params = [\n                    (\"grant_type\", \"authorization_code\"),\n                    (\"code\", &auth_request.code),\n                    (\"redirect_uri\", \"moodring://auth\"),\n                    (\"client_id\", &client_id),\n                    (\"code_verifier\", &auth_request.code_verifier),\n                ];\n\n                client\n                    .post(\"https://accounts.spotify.com/api/token\")\n                    .form(&params)\n                    .header(\n                        \"Authorization\",\n                        format!(\n                            \"Basic {}\",\n                            base64::engine::general_purpose::STANDARD\n                                .encode(format!(\"{client_id}:{client_secret}\"))\n                        ),\n                    )\n                    .send()\n                    .await?\n                    .json::<SpotifyTokenResponse>()\n                    .await\n            })\n        })\n        .map_err(|e: reqwest::Error| format!(\"Token exchange failed: {e}\"))?;\n\n        // Step 2: Get user profile from Spotify\n        let user_profile = tokio::task::block_in_place(|| {\n            let rt = tokio::runtime::Handle::current();\n            rt.block_on(async {\n                let client = reqwest::Client::new();\n                client\n                    .get(\"https://api.spotify.com/v1/me\")\n                    .header(\n                        \"Authorization\",\n                        format!(\"Bearer {}\", token_response.access_token),\n                    )\n                    .send()\n                    .await?\n                    .json::<SpotifyUserProfile>()\n                    .await\n            })\n        })\n        .map_err(|e: reqwest::Error| format!(\"Profile fetch failed: {e}\"))?;\n\n        // Step 3: Create or update user in database\n        let expires_at =\n            chrono::Utc::now().naive_utc() + chrono::Duration::seconds(token_response.expires_in);\n        let profile_image = user_profile.images.first().map(|img| img.url.clone());\n\n        let new_user = NewUser {\n            spotify_id: user_profile.id.clone(),\n            email: user_profile.email.clone().unwrap_or_default(),\n            display_name: user_profile.display_name.clone(),\n            spotify_access_token: Some(token_response.access_token.clone()),\n            spotify_refresh_token: token_response.refresh_token.clone(),\n            token_expires_at: Some(expires_at),\n            profile_image_url: profile_image,\n        };\n\n        // Try to find existing user first\n        let result_user = match users\n            .filter(spotify_id.eq(&user_profile.id))\n            .first::<User>(&mut conn)\n        {\n            Ok(_existing_user) => {\n                // Update existing user\n                diesel::update(users.filter(spotify_id.eq(&user_profile.id)))\n                    .set((\n                        email.eq(&new_user.email),\n                        display_name.eq(&new_user.display_name),\n                        spotify_access_token.eq(&new_user.spotify_access_token),\n                        spotify_refresh_token.eq(&new_user.spotify_refresh_token),\n                        token_expires_at.eq(&new_user.token_expires_at),\n                        profile_image_url.eq(&new_user.profile_image_url),\n                        updated_at.eq(chrono::Utc::now().naive_utc()),\n                    ))\n                    .get_result::<User>(&mut conn)\n                    .map_err(|e| format!(\"Failed to update user: {e}\"))\n            }\n            Err(diesel::NotFound) => {\n                // Create new user\n                diesel::insert_into(users)\n                    .values(&new_user)\n                    .get_result::<User>(&mut conn)\n                    .map_err(|e| format!(\"Failed to create user: {e}\"))\n            }\n            Err(e) => Err(format!(\"Database error: {e}\")),\n        }?;\n\n        // Generate a simple JWT token (in production, use proper JWT implementation)\n        let jwt_token = format!(\"user_token_{}\", result_user.id);\n        Ok(AuthResponse {\n            user: result_user,\n            access_token: jwt_token,\n        })\n    })\n    .await\n    .map_err(|e| format!(\"Task join error: {e}\"))?\n}\n\n#[cfg(test)]\npub mod test_helpers {\n    use super::*;\n    use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};\n    use std::env;\n\n    pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(\"migrations\");\n\n    pub fn setup_test_db() -> DbPool {\n        let database_url = env::var(\"TEST_DATABASE_URL\").unwrap_or_else(|_| {\n            \"postgresql://postgres:password@localhost/moodring_test\".to_string()\n        });\n\n        let manager = diesel::r2d2::ConnectionManager::<PgConnection>::new(&database_url);\n        let pool = diesel::r2d2::Pool::builder()\n            .max_size(1)\n            .build(manager)\n            .expect(\"Failed to create test pool\");\n\n        // Run migrations\n        let mut conn = pool.get().expect(\"Failed to get connection\");\n        conn.run_pending_migrations(MIGRATIONS)\n            .expect(\"Failed to run migrations\");\n\n        pool\n    }\n\n    pub fn cleanup_test_db(pool: &DbPool) {\n        use schema::users::dsl::*;\n        let mut conn = pool.get().expect(\"Failed to get connection\");\n        diesel::delete(users)\n            .execute(&mut conn)\n            .expect(\"Failed to cleanup users\");\n    }\n\n    pub fn create_mock_spotify_user() -> SpotifyUserProfile {\n        SpotifyUserProfile {\n            id: \"test_spotify_id\".to_string(),\n            email: Some(\"test@example.com\".to_string()),\n            display_name: Some(\"Test User\".to_string()),\n            images: vec![SpotifyImage {\n                url: \"https://example.com/avatar.jpg\".to_string(),\n                height: Some(300),\n                width: Some(300),\n            }],\n        }\n    }\n\n    pub fn create_mock_token_response() -> SpotifyTokenResponse {\n        SpotifyTokenResponse {\n            access_token: \"mock_access_token\".to_string(),\n            token_type: \"Bearer\".to_string(),\n            scope: \"user-read-private user-read-email\".to_string(),\n            expires_in: 3600,\n            refresh_token: Some(\"mock_refresh_token\".to_string()),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use serde_json::json;\n    use std::env;\n\n    #[tokio::test]\n    async fn test_new_user_struct_creation() {\n        let new_user = NewUser {\n            spotify_id: \"test_spotify_123\".to_string(),\n            email: \"test@example.com\".to_string(),\n            display_name: Some(\"Test User\".to_string()),\n            spotify_access_token: Some(\"access_token_123\".to_string()),\n            spotify_refresh_token: Some(\"refresh_token_123\".to_string()),\n            token_expires_at: Some(chrono::Utc::now().naive_utc() + chrono::Duration::hours(1)),\n            profile_image_url: Some(\"https://example.com/avatar.jpg\".to_string()),\n        };\n\n        assert_eq!(new_user.spotify_id, \"test_spotify_123\");\n        assert_eq!(new_user.email, \"test@example.com\");\n        assert_eq!(new_user.display_name, Some(\"Test User\".to_string()));\n        assert_eq!(\n            new_user.spotify_access_token,\n            Some(\"access_token_123\".to_string())\n        );\n        assert_eq!(\n            new_user.spotify_refresh_token,\n            Some(\"refresh_token_123\".to_string())\n        );\n        assert_eq!(\n            new_user.profile_image_url,\n            Some(\"https://example.com/avatar.jpg\".to_string())\n        );\n    }\n\n    #[tokio::test]\n    async fn test_user_model_serialization() {\n        let user = User {\n            id: 1,\n            spotify_id: \"test_spotify_id\".to_string(),\n            email: \"test@example.com\".to_string(),\n            display_name: Some(\"Test User\".to_string()),\n            spotify_access_token: Some(\"access_token\".to_string()),\n            spotify_refresh_token: Some(\"refresh_token\".to_string()),\n            token_expires_at: Some(chrono::Utc::now().naive_utc()),\n            profile_image_url: Some(\"https://example.com/avatar.jpg\".to_string()),\n            created_at: chrono::Utc::now().naive_utc(),\n            updated_at: chrono::Utc::now().naive_utc(),\n        };\n\n        let serialized = serde_json::to_string(&user).expect(\"Failed to serialize user\");\n        let deserialized: User =\n            serde_json::from_str(&serialized).expect(\"Failed to deserialize user\");\n\n        assert_eq!(user.id, deserialized.id);\n        assert_eq!(user.spotify_id, deserialized.spotify_id);\n        assert_eq!(user.email, deserialized.email);\n    }\n\n    #[tokio::test]\n    async fn test_auth_request_deserialization() {\n        let json_data = json!({\n            \"code\": \"test_auth_code\",\n            \"code_verifier\": \"test_code_verifier\"\n        });\n\n        let auth_request: AuthRequest =\n            serde_json::from_value(json_data).expect(\"Failed to deserialize AuthRequest\");\n\n        assert_eq!(auth_request.code, \"test_auth_code\");\n        assert_eq!(auth_request.code_verifier, \"test_code_verifier\");\n    }\n\n    #[tokio::test]\n    async fn test_auth_response_serialization() {\n        let user = User {\n            id: 1,\n            spotify_id: \"test_spotify_id\".to_string(),\n            email: \"test@example.com\".to_string(),\n            display_name: Some(\"Test User\".to_string()),\n            spotify_access_token: Some(\"access_token\".to_string()),\n            spotify_refresh_token: Some(\"refresh_token\".to_string()),\n            token_expires_at: Some(chrono::Utc::now().naive_utc()),\n            profile_image_url: Some(\"https://example.com/avatar.jpg\".to_string()),\n            created_at: chrono::Utc::now().naive_utc(),\n            updated_at: chrono::Utc::now().naive_utc(),\n        };\n\n        let auth_response = AuthResponse {\n            user: user.clone(),\n            access_token: \"jwt_token_123\".to_string(),\n        };\n\n        let serialized =\n            serde_json::to_string(&auth_response).expect(\"Failed to serialize AuthResponse\");\n        let json_value: serde_json::Value =\n            serde_json::from_str(&serialized).expect(\"Failed to parse JSON\");\n\n        assert_eq!(json_value[\"access_token\"], \"jwt_token_123\");\n        assert_eq!(json_value[\"user\"][\"id\"], 1);\n        assert_eq!(json_value[\"user\"][\"spotify_id\"], \"test_spotify_id\");\n    }\n\n    #[test]\n    fn test_missing_environment_variables() {\n        // Temporarily remove environment variables\n        env::remove_var(\"SPOTIFY_CLIENT_ID\");\n        env::remove_var(\"SPOTIFY_CLIENT_SECRET\");\n\n        // Test that missing env vars are handled properly\n        let client_id_result = env::var(\"SPOTIFY_CLIENT_ID\");\n        let client_secret_result = env::var(\"SPOTIFY_CLIENT_SECRET\");\n\n        assert!(client_id_result.is_err());\n        assert!(client_secret_result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_spotify_token_response_deserialization() {\n        let json_data = json!({\n            \"access_token\": \"mock_access_token\",\n            \"token_type\": \"Bearer\",\n            \"scope\": \"user-read-private user-read-email\",\n            \"expires_in\": 3600,\n            \"refresh_token\": \"mock_refresh_token\"\n        });\n\n        let token_response: SpotifyTokenResponse =\n            serde_json::from_value(json_data).expect(\"Failed to deserialize SpotifyTokenResponse\");\n\n        assert_eq!(token_response.access_token, \"mock_access_token\");\n        assert_eq!(token_response.token_type, \"Bearer\");\n        assert_eq!(token_response.scope, \"user-read-private user-read-email\");\n        assert_eq!(token_response.expires_in, 3600);\n        assert_eq!(\n            token_response.refresh_token,\n            Some(\"mock_refresh_token\".to_string())\n        );\n    }\n\n    #[tokio::test]\n    async fn test_spotify_user_profile_deserialization() {\n        let json_data = json!({\n            \"id\": \"test_spotify_id\",\n            \"email\": \"test@example.com\",\n            \"display_name\": \"Test User\",\n            \"images\": [\n                {\n                    \"url\": \"https://example.com/avatar.jpg\",\n                    \"height\": 300,\n                    \"width\": 300\n                }\n            ]\n        });\n\n        let user_profile: SpotifyUserProfile =\n            serde_json::from_value(json_data).expect(\"Failed to deserialize SpotifyUserProfile\");\n\n        assert_eq!(user_profile.id, \"test_spotify_id\");\n        assert_eq!(user_profile.email, Some(\"test@example.com\".to_string()));\n        assert_eq!(user_profile.display_name, Some(\"Test User\".to_string()));\n        assert_eq!(user_profile.images.len(), 1);\n        assert_eq!(user_profile.images[0].url, \"https://example.com/avatar.jpg\");\n        assert_eq!(user_profile.images[0].height, Some(300));\n        assert_eq!(user_profile.images[0].width, Some(300));\n    }\n\n    #[tokio::test]\n    async fn test_auth_request_validation() {\n        let valid_request = AuthRequest {\n            code: \"valid_auth_code_12345\".to_string(),\n            code_verifier: \"valid_code_verifier_12345\".to_string(),\n        };\n\n        assert!(!valid_request.code.is_empty());\n        assert!(!valid_request.code_verifier.is_empty());\n        assert!(valid_request.code.len() > 10);\n        assert!(valid_request.code_verifier.len() > 10);\n    }\n}\n","traces":[{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":84},{"path":["/","Users","anthonypelusocook","moodring-vibe","moodring_backend","src","main.rs"],"content":"#[macro_use]\nextern crate rocket;\n\nextern crate diesel;\n\nuse diesel::prelude::*;\nuse rocket::serde::{json::Json, Deserialize, Serialize};\nuse rocket::{tokio, State};\nuse std::env;\n\nuse moodring_backend::*;\n\n// TODO: TEMP - Remove this model when moving to real features\n#[derive(Queryable, Serialize, Deserialize)]\n#[serde(crate = \"rocket::serde\")]\n#[diesel(table_name = schema::temp_songs)]\npub struct TempSong {\n    pub id: i32,\n    pub title: String,\n    pub artist: String,\n    pub genre: Option<String>,\n    pub created_at: chrono::NaiveDateTime,\n    pub updated_at: chrono::NaiveDateTime,\n}\n\n// TODO: TEMP - Remove this struct when moving to real features\n#[derive(Insertable, Serialize, Deserialize)]\n#[serde(crate = \"rocket::serde\")]\n#[diesel(table_name = schema::temp_songs)]\npub struct NewTempSong {\n    pub title: String,\n    pub artist: String,\n    pub genre: Option<String>,\n}\n\n#[derive(Serialize, Deserialize)]\n#[serde(crate = \"rocket::serde\")]\nstruct HealthResponse {\n    status: String,\n    message: String,\n}\n\n// TODO: TEMP - Remove this struct when removing test endpoint\n#[derive(Serialize, Deserialize)]\n#[serde(crate = \"rocket::serde\")]\nstruct TestDataResponse {\n    message: String,\n    data: Vec<String>,\n    timestamp: String,\n}\n\n#[get(\"/health\")]\nfn health() -> Json<HealthResponse> {\n    Json(HealthResponse {\n        status: \"ok\".to_string(),\n        message: \"Moodring backend is running\".to_string(),\n    })\n}\n\n#[get(\"/\")]\nfn index() -> &'static str {\n    \"Welcome to Moodring API\"\n}\n\n// TODO: TEMP - Remove this test endpoint when moving to real features\n#[get(\"/test-data\")]\nfn test_data() -> Json<TestDataResponse> {\n    use chrono::Utc;\n\n    Json(TestDataResponse {\n        message: \"Hello from Moodring backend!\".to_string(),\n        data: vec![\n            \"🎵 Song 1: Bohemian Rhapsody\".to_string(),\n            \"🎵 Song 2: Stairway to Heaven\".to_string(),\n            \"🎵 Song 3: Hotel California\".to_string(),\n            \"🎵 Song 4: Sweet Child O' Mine\".to_string(),\n        ],\n        timestamp: Utc::now().to_rfc3339(),\n    })\n}\n\n// TODO: TEMP - Remove these database endpoints when moving to real features\n#[get(\"/songs\")]\nasync fn get_songs(\n    pool: &State<DbPool>,\n) -> Result<Json<Vec<TempSong>>, rocket::response::status::BadRequest<String>> {\n    use schema::temp_songs::dsl::*;\n\n    let pool = pool.inner().clone();\n\n    match tokio::task::spawn_blocking(move || {\n        let mut conn = pool\n            .get()\n            .map_err(|e| format!(\"Failed to get connection: {e}\"))?;\n        temp_songs\n            .load::<TempSong>(&mut conn)\n            .map_err(|e| format!(\"Failed to load songs: {e}\"))\n    })\n    .await\n    {\n        Ok(Ok(songs)) => Ok(Json(songs)),\n        Ok(Err(e)) => Err(rocket::response::status::BadRequest(e)),\n        Err(e) => Err(rocket::response::status::BadRequest(format!(\n            \"Task join error: {e}\"\n        ))),\n    }\n}\n\n#[post(\"/songs\", data = \"<new_song>\")]\nasync fn create_song(\n    pool: &State<DbPool>,\n    new_song: Json<NewTempSong>,\n) -> Result<Json<TempSong>, rocket::response::status::BadRequest<String>> {\n    use schema::temp_songs::dsl::*;\n\n    let pool = pool.inner().clone();\n    let new_song_data = new_song.into_inner();\n\n    match tokio::task::spawn_blocking(move || {\n        let mut conn = pool\n            .get()\n            .map_err(|e| format!(\"Failed to get connection: {e}\"))?;\n        diesel::insert_into(temp_songs)\n            .values(&new_song_data)\n            .get_result::<TempSong>(&mut conn)\n            .map_err(|e| format!(\"Failed to create song: {e}\"))\n    })\n    .await\n    {\n        Ok(Ok(song)) => Ok(Json(song)),\n        Ok(Err(e)) => Err(rocket::response::status::BadRequest(e)),\n        Err(e) => Err(rocket::response::status::BadRequest(format!(\n            \"Task join error: {e}\"\n        ))),\n    }\n}\n\n#[put(\"/songs/<song_id>\", data = \"<updated_song>\")]\nasync fn update_song(\n    pool: &State<DbPool>,\n    song_id: i32,\n    updated_song: Json<NewTempSong>,\n) -> Result<Json<TempSong>, rocket::response::status::BadRequest<String>> {\n    use schema::temp_songs::dsl::*;\n\n    let pool = pool.inner().clone();\n    let updated_data = updated_song.into_inner();\n\n    match tokio::task::spawn_blocking(move || {\n        let mut conn = pool\n            .get()\n            .map_err(|e| format!(\"Failed to get connection: {e}\"))?;\n        diesel::update(temp_songs.filter(id.eq(song_id)))\n            .set((\n                title.eq(&updated_data.title),\n                artist.eq(&updated_data.artist),\n                genre.eq(&updated_data.genre),\n                updated_at.eq(chrono::Utc::now().naive_utc()),\n            ))\n            .get_result::<TempSong>(&mut conn)\n            .map_err(|e| format!(\"Failed to update song: {e}\"))\n    })\n    .await\n    {\n        Ok(Ok(song)) => Ok(Json(song)),\n        Ok(Err(e)) => Err(rocket::response::status::BadRequest(e)),\n        Err(e) => Err(rocket::response::status::BadRequest(format!(\n            \"Task join error: {e}\"\n        ))),\n    }\n}\n\n#[delete(\"/songs/<song_id>\")]\nasync fn delete_song(\n    pool: &State<DbPool>,\n    song_id: i32,\n) -> Result<rocket::response::status::NoContent, rocket::response::status::BadRequest<String>> {\n    use schema::temp_songs::dsl::*;\n\n    let pool = pool.inner().clone();\n\n    match tokio::task::spawn_blocking(move || {\n        let mut conn = pool\n            .get()\n            .map_err(|e| format!(\"Failed to get connection: {e}\"))?;\n        diesel::delete(temp_songs.filter(id.eq(song_id)))\n            .execute(&mut conn)\n            .map_err(|e| format!(\"Failed to delete song: {e}\"))\n    })\n    .await\n    {\n        Ok(Ok(rows_affected)) => {\n            if rows_affected > 0 {\n                Ok(rocket::response::status::NoContent)\n            } else {\n                Err(rocket::response::status::BadRequest(\n                    \"Song not found\".to_string(),\n                ))\n            }\n        }\n        Ok(Err(e)) => Err(rocket::response::status::BadRequest(e)),\n        Err(e) => Err(rocket::response::status::BadRequest(format!(\n            \"Task join error: {e}\"\n        ))),\n    }\n}\n\n// Authentication endpoint\n#[post(\"/auth/spotify\", data = \"<auth_request>\")]\nasync fn spotify_auth(\n    pool: &State<DbPool>,\n    auth_request: Json<AuthRequest>,\n) -> Result<Json<AuthResponse>, rocket::response::status::BadRequest<String>> {\n    let auth_data = auth_request.into_inner();\n    match authenticate_user_with_spotify(pool.inner(), auth_data).await {\n        Ok(auth_response) => Ok(Json(auth_response)),\n        Err(e) => Err(rocket::response::status::BadRequest(e)),\n    }\n}\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<rocket::Error>> {\n    dotenvy::dotenv().ok();\n\n    // TODO: TEMP - Remove database setup when moving to real features\n    let database_url = env::var(\"DATABASE_URL\").expect(\"DATABASE_URL must be set\");\n\n    let manager = diesel::r2d2::ConnectionManager::<PgConnection>::new(database_url);\n    let pool = diesel::r2d2::Pool::builder()\n        .build(manager)\n        .expect(\"Failed to create pool\");\n\n    let _rocket = rocket::build()\n        .manage(pool)\n        .mount(\n            \"/\",\n            routes![\n                index,\n                health,\n                test_data,\n                spotify_auth,\n                get_songs,\n                create_song,\n                update_song,\n                delete_song\n            ],\n        )\n        .launch()\n        .await\n        .map_err(Box::new)?;\n\n    Ok(())\n}\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":108},{"path":["/","Users","anthonypelusocook","moodring-vibe","moodring_backend","src","schema.rs"],"content":"// @generated automatically by Diesel CLI.\n\ndiesel::table! {\n    temp_songs (id) {\n        id -> Int4,\n        title -> Varchar,\n        artist -> Varchar,\n        genre -> Nullable<Varchar>,\n        created_at -> Timestamp,\n        updated_at -> Timestamp,\n    }\n}\n\ndiesel::table! {\n    users (id) {\n        id -> Int4,\n        spotify_id -> Varchar,\n        email -> Varchar,\n        display_name -> Nullable<Varchar>,\n        spotify_access_token -> Nullable<Varchar>,\n        spotify_refresh_token -> Nullable<Varchar>,\n        token_expires_at -> Nullable<Timestamp>,\n        profile_image_url -> Nullable<Varchar>,\n        created_at -> Timestamp,\n        updated_at -> Timestamp,\n    }\n}\n\ndiesel::allow_tables_to_appear_in_same_query!(temp_songs, users,);\n","traces":[],"covered":0,"coverable":0}],"coverage":0.0,"covered":0,"coverable":192}